<html>
<head>
<title>Telepathy Specification</title>
</head>
<body>
<h1>Telepathy Specification</h1>

<h3>Connection Managers</h3>
<p>The mission control library reads files on disk to determine available
connection managers, and the protocols they support, listed as activatable
service names of the form:</p>
<code> org.freedesktop.Telepathy.connectionmanager.{manager specific identifier}</code>
<br>
<p>Once activated, the connection manager provides an object implementing the
interface:</p>
<code> org.freedesktop.Telepathy.connectionmanager</code>

<p>Named:</p>
<code> /org/freedesktop/Telepathy/connectionmanager/{manager specific identifier}</code>
<p>Which provides methods to query available protocols, and create a connection.</p>

<br>
<p>When a connection is created, the manager appears as a service of the form:</p>
<code> org.freedesktop.Telepathy.connection.{protocol}.{protocol specific connection identifier}</code>
<p>A manager which is only capable of managing a single connection would then
deregister its <code>org.freedesktop.Telepathy.connectionmanager.* </code> identifier, causing
another instance to be activated when another connection is required.

<h3>Connections</h3>
<p>The connection service provides an object implementing the interface:</p>
<code> org.freedesktop.Telepathy.connection</code>
<p>Named:</p>
<code> /org/freedesktop/Telepathy/connection/{protocol}/{protocol specific connection identifier}</code>
<p>Which provides methods to query the channels that the connection currently
has open, create channels, query available contacts, add/remove contacts,
disconnect, etc, and emits signals for changes in these entities.</p>

<h3>Channels</h3>
<p>Communication channels should provide interfaces that implement the
capabilities with which they were created.</p>
<p>If a service asynchonously requests a channel, the connection creates an object for this channel and signals its creation</p>


<h3>Thoughts</h3>
<p>Incoming messages are emitted as signals.
In order to avoid message delivery when no client is listening, an channel should be able to tell if it has anyone listening to it. We could do this by having each connection maintain a list of registered listeners by bus name, so they can be deregistered if dbus signals that they have gone away. Another option is adding the functionality to dbus to allow a service to ask who is listening to its signals (enumerate connections that have match rules). Yet another possibilty is Colin Walters recently specified Channel interface.</p>

<h3>Presence Manager</h3>
<p> We will use Galago, and implement a feed for Telepathy which listens to signals emitted by connection managers and updates the mapping in galago of contacts to their current capabilities on the availiable connections.</p> 
<p>Support for capabilities will be implemented in galago.</p>


<h3>Interface Specifications:</h3>
<pre>
org.freedesktop.Telepathy.connectionmanager:
        methods:
                make_connection(s:proto,s:account, a{ss}:connect_info)
                proto: protocol name
                account: account name
                connect_info: the rest of how to connect to the server
                        e.g. {server:jabber.org, port:55555, password:s3cr1t}
                return (s:protocol specific account identifier)
        


org.freedesktop.Telepathy.connection:
        methods:
                create_channel(in:s:proto specific endpoint id, in:as:capabilities, out:s:objectname)
                
        signals:
                channel_created(out:s: proto specific endpoint id, out:as:caps, out:objectname)
                
                
org.freedesktop.Telepathy.channel:
        signals:
                caps_changed(as:caps)
        methods:
                as:caps get_caps()
                close()

org.freedesktop.Telepathy.channel.text:
        
       i:msgid send(s:text)
</pre>       
</body>
</html>
